# DEMO PROJECT: Eternal Fusion Pavilion

## Description

A simple prototype of a **Restaurant Reservation Management System**.

## Disclaimer

* This project is intended for **educational, testing, and experimentation purposes only**.
* Approximately 98% of the code was generated by AI.
* **Not suitable for production use**.
* Use at your own risk. No warranties, guarantees, or support are provided.

# **Local Development Guide for Windows 11**

This guide provides step-by-step instructions to run the Eternal Fusion Pavilion full-stack application (Flask backend + React frontend) locally on Windows 11 for development purposes.

## **Prerequisites**

* **Backend**: Flask (Python)
* **Frontend**: React (JSX)
* **Database**: PostgreSQL
* **Package Managers**: pip (Python), npm (Node.js)
* **OS**: Windows 11


---

## **Step 1: Clone the Repository**

1. Open **Command Prompt** or **PowerShell**
2. Navigate to your desired directory (e.g., `C:\Projects`)
3. Clone the repository:
   ```bash
   git clone https://github.com/stephen-cpe/eternal_fusion_pavilion.git
   cd eternal_fusion_pavilion
   ```

---

## **Step 2: Set Up PostgreSQL Database**

1. **Open pgAdmin** (installed with PostgreSQL) or use **psql** command line

2. **Create Database and User**:
   - If using psql, open Command Prompt and run:
     ```bash
     psql -U postgres
     ```
   - Enter your postgres password when prompted
   
     > **Note:** Only run this following SQL commands if you want to start project again from scratch
     ```sql
     DROP DATABASE IF EXISTS eternal_fusion_pavilion_database;
	 DROP USER IF EXISTS efp_user;
     ```
   
   - Run the following SQL commands:
     ```sql
     CREATE USER efp_user WITH PASSWORD 'strongpassword';
	 CREATE DATABASE eternal_fusion_pavilion_database;
	 ALTER DATABASE eternal_fusion_pavilion_database OWNER TO efp_user;
     \q
     ```

3. **Initialize Database Schema**:
   - Navigate to the project directory in Command Prompt:
     ```bash
     cd C:\Projects\eternal_fusion_pavilion
     psql -U postgres -d eternal_fusion_pavilion_database -f init_db.sql
     ```
   - Enter your postgres password when prompted

---

## **Step 3: Configure Backend (Flask)**

1. **Navigate to Backend Directory**:
   ```bash
   cd backend
   ```

2. **Create Virtual Environment**:
   ```bash
   python -m venv venv
   ```

3. **Activate Virtual Environment**:
   ```bash
   # For Command Prompt:
   venv\Scripts\activate

   # For PowerShell:
   venv\Scripts\Activate.ps1
   ```
   
   > **Note**: If you get an execution policy error in PowerShell, run:
   > ```powershell
   > Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
   > ```

4. **Install Dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

5. **Create Environment File**:
   - Create a `.env` file in the backend directory:
   ```bash
   # In backend directory
   echo. > .env
   ```
   - Open `.env` in a text editor and add:
   ```
   DB_HOST=localhost
   DB_PORT=5432
   DB_NAME=eternal_fusion_pavilion_database
   DB_USER=efp_user
   DB_PASSWORD=strongpassword
   SECRET_KEY=generate_a_very_secret_key
   API_PREFIX=/api
   FLASK_ENV=development
   FLASK_DEBUG=True
   ```

6. **Run Flask Development Server**:
   ```bash
   # Make sure virtual environment is activated
   python app.py
   ```
   - The backend should now be running at `http://localhost:5000`
   - Keep this terminal window open

---

## **Step 4: Configure Frontend (React)**

1. **Open a New Terminal Window** (keep the backend running)

2. **Navigate to Frontend Directory**:
   ```bash
   cd C:\Projects\eternal_fusion_pavilion\frontend
   ```

3. **Install Dependencies**:
   ```bash
   npm install
   ```

4. **Configure API Endpoint** (if needed):
   - Check if there's a configuration file (e.g., `src/config.js` or `.env`) in the frontend directory
   - Ensure the API URL points to `http://localhost:5000/api`
   - If using environment variables, create a `.env` file in the frontend directory:
   ```
   VITE_API_URL=http://localhost:5000/api
   REACT_APP_API_URL=http://localhost:5000/api
   ```

5. **Start React Development Server**:
   ```bash
   npm start
   ```
   - The application should automatically open in your browser at `http://localhost:3000`
   - If it doesn't, manually navigate to `http://localhost:3000`

---

## **Step 5: Verify Application**

1. **Test the Application**:
   - Open your browser and go to `http://localhost:3000`
   - The React frontend should load successfully
   - Test API connectivity by attempting to log in or interact with features

2. **Default Admin Credentials** (if seeded by init_db.sql):
   - Check the `init_db.sql` file for any default admin credentials that may have been created

---

## **Development Workflow**

### **Running the Application**
Each time you want to run the application locally:

1. **Terminal 1 - Backend**:
   ```bash
   cd C:\Projects\eternal_fusion_pavilion\backend
   venv\Scripts\activate
   python app.py
   ```

2. **Terminal 2 - Frontend**:
   ```bash
   cd C:\Projects\eternal_fusion_pavilion\frontend
   npm start
   ```

### **Stopping the Application**
- Press `Ctrl + C` in each terminal to stop the servers

## **Additional Notes**

- This setup is for **development only**. Do not use these configurations in production.
- The Flask development server auto-reloads when you make changes to Python files
- React development server includes hot-reloading for frontend changes
- Keep both terminal windows open while developing
- Consider using VS Code with integrated terminals for easier development

--------

# **Deployment Guide on AWS EC2**

This guide provides step-by-step instructions to deploy a full-stack application (Flask backend + React frontend) on an AWS EC2 instance running **Ubuntu 24.04 LTS**.

The production environment uses **Nginx** as a reverse proxy and static file server, **Gunicorn** as the WSGI server for Flask, and **PostgreSQL** as the database.

## **Technology Stack**

  * **Backend**: Flask (Python)
  * **Frontend**: React (JSX)
  * **Database**: PostgreSQL
  * **WSGI Server**: Gunicorn 
  * **Web/Proxy Server**: Nginx 
  * **OS**: Ubuntu 24.04 LTS
  * **Process Manager**: systemd

-----

## **Step 1: Initial EC2 & System Setup**

First, prepare the server instance and install all required software.

1.  **Launch & Connect to EC2**:

      * In the AWS console, launch a new EC2 instance (e.g., `t2.micro` or larger) using the **Ubuntu Server 24.04 LTS** AMI.
      * Configure the **Security Group** with inbound rules to allow traffic for:
          * **SSH** (Port 22) - From your IP for access.
          * **HTTP** (Port 80) - From `Anywhere` (0.0.0.0/0, ::/0).
          * **HTTPS** (Port 443) - From `Anywhere` (0.0.0.0/0, ::/0).
      * Connect to your instance via SSH using your key pair:
        ```bash
        ssh -i "your-key-pair.pem" ubuntu@ec2-54-235-238-98.compute-1.amazonaws.com
        ```
      * _Replace all reference to `ec2-54-235-238-98.compute-1.amazonaws.com` with your AWS EC2 Public DNS._ 
        

2.  **Update System & Install Packages**:

      * Update the package lists and upgrade existing packages:
        ```bash
        sudo apt update && sudo apt upgrade -y
        ```
      * Install all necessary dependencies including Python, Node.js, PostgreSQL, and Nginx:
        ```bash
        sudo apt install -y python3 python3-venv python3-pip nodejs npm postgresql nginx git
        ```

3.  **Configure the Firewall (UFW)**:

      * Allow SSH and Nginx traffic through the local firewall.
        ```bash
        sudo ufw allow OpenSSH
        sudo ufw allow 'Nginx Full'
        ```
      * Enable the firewall. **Confirm "y"** when prompted.
        ```bash
        sudo ufw enable
        ```
      * Verify that the firewall is active and the rules are applied:
        ```bash
        sudo ufw status verbose
        ```

-----

## **Step 2: Deploy Code and Configure Environment**

Clone the application code onto the server and set up the necessary environment variables.

1.  **Clone the Repository**:

      * Clone the project into the `ubuntu` user's home directory. (The troubleshooting shows `/home/ubuntu/eternal_fusion_pavilion` as the final working directory).
        ```bash
        git clone https://github.com/stephen-cpe/eternal_fusion_pavilion.git eternal_fusion_pavilion
        ```

2.  **Create Environment File**:

      * Create and edit a `.env` file in the project's root directory:
        ```bash
        nano ~/eternal_fusion_pavilion/.env
        ```
      * Add the following variables, replacing placeholder values. **Use the password you created in Step 2**.
        ```
        DB_HOST=localhost
        DB_PORT=5432
        DB_NAME=eternal_fusion_pavilion_database
        DB_USER=efp_user
        DB_PASSWORD=strongpassword
        SECRET_KEY=generate_a_very_secret_key
        API_PREFIX=/api
        ```
      * **Note**: Ensure the Flask `config.py` is updated to load these variables using `os.getenv()`.

-----

## **Step 3: Set Up PostgreSQL Database**

Create the database, a dedicated user, and initialize the table schema.


1.  **Start and Enable PostgreSQL Service**

    ```bash
    sudo systemctl start postgresql
    sudo systemctl enable postgresql
    ```

2.  **Create Database and User**

      * Add postgres User to ubuntu Group:
        ```bash
        sudo usermod -aG ubuntu postgres
        ```

      * Access the PostgreSQL prompt:
        ```bash
        sudo -u postgres psql
        ```
      * Run the following SQL commands to create the user and database. Replace `'strongpassword'` with a secure password:
        ```sql
        CREATE USER efp_user WITH PASSWORD 'strongpassword';
        CREATE DATABASE eternal_fusion_pavilion_database;
        GRANT ALL PRIVILEGES ON DATABASE eternal_fusion_pavilion_database TO efp_user;
        \q
        ```

	
3.  **Initialize the Database Schema**

      * With the database and user created, run the `init_db.sql` script to create all necessary tables and seed initial data (like the admin account).
      * Execute the script as the `postgres` superuser to ensure all permissions are handled correctly:
        ```bash
        sudo -u postgres psql -d eternal_fusion_pavilion_database -f ~/eternal_fusion_pavilion/init_db.sql
        ```

4.  **(Optional) Verify Initialization**

      * You can verify that the tables were created successfully by connecting to the database and listing the tables.
        ```bash
        # Connect to the database
        sudo -u postgres psql -d eternal_fusion_pavilion_database

        # List tables (at the psql prompt)
        \dt

        # Exit
        \q
        ```
-----


## **Step 4: Configure Backend (Flask & Gunicorn)**

Set up the Python environment, install dependencies, and create a systemd service to manage the Gunicorn process.

1.  **Create Virtual Environment & Install Dependencies**:

      * Navigate to the backend directory and create a virtual environment:
        ```bash
        cd ~/eternal_fusion_pavilion/backend
        python3 -m venv venv
        ```
      * Activate the environment and install the required packages:
        ```bash
        source venv/bin/activate
        pip install -r requirements.txt gunicorn
        ```

2.  **Create Gunicorn Systemd Service**:

      * Create a service file to manage the backend process
        ```bash
        sudo nano /etc/systemd/system/efp-backend.service
      * Paste in the following configuration. This is the **final corrected version** that ensures Nginx can communicate with the Gunicorn socket:
        ```
        [Unit]
        Description=Eternal Fusion Pavilion Backend
        After=network.target

        [Service]
        User=ubuntu
        Group=www-data
        WorkingDirectory=/home/ubuntu/eternal_fusion_pavilion/backend
        EnvironmentFile=/home/ubuntu/eternal_fusion_pavilion/.env
        ExecStart=/home/ubuntu/eternal_fusion_pavilion/backend/venv/bin/gunicorn --workers 3 --bind unix:/home/ubuntu/eternal_fusion_pavilion/efp.sock -m 007 "app:create_app()"
        Restart=always

        [Install]
        WantedBy=multi-user.target
        ```
          * **`User=ubuntu`**: Runs the process as the user.
          * **`Group=www-data`**: Allows the Nginx process group to access the socket.
          * **`-m 007`**: Sets the socket file permissions so the `www-data` group can read and write to it.

-----

## **Step 5: Configure Frontend (React & Nginx)**

Build the static React files and configure Nginx to serve them and proxy API calls to the backend.

1.  **Build the React App**:

      * Navigate to the frontend directory, install dependencies, and create the production build:
        ```bash
        cd ~/eternal_fusion_pavilion/frontend
        sudo npm install -g n
        sudo n lts
        npm install
        npm run build
        ```

2.  **Set Build File Permissions**:

      * This is a **critical step** to prevent "500 Internal Server Error" issues. Nginx (running as `www-data`) needs permission to read the files in the `/home/ubuntu` directory.
      * Change the group ownership of the build directory to `www-data`:
        ```bash
        sudo chown -R ubuntu:www-data ~/eternal_fusion_pavilion/frontend/dist
        ```
      * Set the correct permissions for directories (755) and files (644):
        ```bash
        sudo find ~/eternal_fusion_pavilion/frontend/dist -type d -exec chmod 755 {} \;
        sudo find ~/eternal_fusion_pavilion/frontend/dist -type f -exec chmod 644 {} \;
        ```

3.  **Configure Nginx**:

      * Create a new Nginx configuration file:
        ```bash
        sudo nano /etc/nginx/sites-available/efp
        ```

      * _Replace all reference to `ec2-54-235-238-98.compute-1.amazonaws.com` and `54.235.238.98` with your AWS EC2 Public DNS and Public IP._

      * Paste the following configuration. This serves the React app, proxies API requests to the Gunicorn socket, and includes a self-signed SSL certificate for HTTPS testing.
        ```nginx
        server {
            listen 80;
            listen 443 ssl;
            server_name ec2-54-235-238-98.compute-1.amazonaws.com 54.235.238.98;

            # Self-signed SSL certificate paths
            ssl_certificate /etc/ssl/certs/selfsigned.crt;
            ssl_certificate_key /etc/ssl/private/selfsigned.key;

            location / {
                root /home/ubuntu/eternal_fusion_pavilion/frontend/dist;
                index index.html;
                try_files $uri /index.html;
            }

            location /api/ {
                proxy_pass http://unix:/home/ubuntu/eternal_fusion_pavilion/efp.sock;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
        }
        ```
      * Enable the site by creating a symbolic link:
        ```bash
        sudo ln -s /etc/nginx/sites-available/efp /etc/nginx/sites-enabled/
        ```
      * Generate a self-signed SSL certificate for testing:
        ```bash
        sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/selfsigned.key -out /etc/ssl/certs/selfsigned.crt -subj "/CN=ec2-54-235-238-98.compute-1.amazonaws.com"
        ```

-----

## **Step 6: Launch and Test**

Start all services and verify that the application is running correctly.

1.  **Start and Enable Services**:

      * Reload the systemd daemon to recognize the new `efp-backend.service`.
        ```bash
        sudo systemctl daemon-reload
        ```
      * Start and enable the backend service:
        ```bash
        sudo systemctl start efp-backend
        sudo systemctl enable efp-backend
        ```
      * Test the Nginx configuration and restart the service:
        ```bash
        sudo nginx -t
        sudo systemctl restart nginx
        ```
      * If this part returns an error, modify `/etc/nginx/nginx.conf`
        ```bash
        sudo nano /etc/nginx/nginx.conf
        ```
        Uncomment and set `server_names_hash_bucket_size 128;`

2.  **Verify Application**:

      * Check that the Gunicorn socket file was created successfully:
        ```bash
        ls -l ~/eternal_fusion_pavilion/efp.sock
        ```
        You should see output like: `srw-rw---- 1 ubuntu www-data 0 Sep 01 12:55 efp.sock`
      * Visit the application in the browser. You will need to bypass the browser warning for the self-signed SSL certificate.
          * **HTTP**: `http://ec2-54-235-238-98.compute-1.amazonaws.com`
          * **HTTPS**: `https://ec2-54-235-238-98.compute-1.amazonaws.com`

-----

## **Service Management & Troubleshooting**

### **Managing Services**

Use the following `systemctl` commands to manage the core services.

```bash
# Check Status (nginx, efp-backend, postgresql)
sudo systemctl status efp-backend

# Stop/Start/Restart
sudo systemctl restart efp-backend
```

### **Common Issues**

If the application is not working as expected, check the following common issues first.

1.  **Nginx Fails to Start (Hash Bucket Size Error)**
    If `sudo nginx -t` fails with a `server_names_hash_bucket_size` error, it means your EC2 DNS name is too long for Nginx's default settings.

      * **Solution**: Edit the main Nginx config file: `sudo nano /etc/nginx/nginx.conf`.
      * Inside the `http { ... }` block, find the line `# server_names_hash_bucket_size 64;` and uncomment it (remove the `#`). If it doesn't exist, add it. Save the file and run `sudo nginx -t` again.

2.  **Permission Denied Errors (Nginx 5xx Errors)**
    If you see Nginx errors related to "permission denied," it means the `www-data` user cannot read the application files.

      * **Solution**: The user home directory (`/home/ubuntu`) permissions must allow execution access for others. Run the following command:
        ```bash
        chmod 755 /home/ubuntu
        ```

> The steps in this guide are sequential and comprehensive. If you encounter issues not listed above, carefully review the previous steps for any missed commands, typos in configuration files, or incorrect values (e.g., hostnames, passwords). Checking service logs with `sudo journalctl -u efp-backend` and `sudo tail -f /var/log/nginx/error.log` will also provide valuable clues.

---

## Project Demo

Watch the demo:

---

## TODO

* Add Unit Tests. Perform Corrective, Adaptive, and Perfective Maintenance.
